# RAII
RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.
在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定

RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子
# sem类 信号量
信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V).假设有信号量SV，对其的P、V操作如下：
  P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行
  V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一
信号量的取值可以是任何自然数，最常用的，最简单的信号量是二进制信号量，只有0和1两个值.

sem_init函数：初始化一个匿名的信号量
原型：int sem_init(sem_t *sem, int pshared, unsigned int value);
  sem：指定了要初始化的信号量的地址；pshared：0表示多线程，非0表示多进程；value：指定了信号量的初始值
sem_destory函数：用于销毁信号量
原型：int sem_destroy(sem_t *sem); sem：指定要销毁的匿名信号量的地址
sem_wait函数：减一操作，如果当前信号的值大于0,继续立即返回；如果当前信号量的值等于0，sem_wait阻塞,直到信号量的值变为大于0。
原型：int sem_wait(sem_t *sem);
sem_post函数：用于将信号量的值增加1。如果有任何线程因为信号量值为0，而阻塞在sem_wait或sem_trywait调用上，sem_post会唤醒其中的一个线程，使其继续执行。
以上，成功返回0，失败返回errno

# locker类 互斥量 
互斥锁,也成互斥量,可以保护关键代码段,以确保独占式访问.当进入关键代码段,获得互斥锁将其加锁;离开关键代码段,唤醒等待该互斥锁的线程.

pthread_mutex_init函数：用于初始化互斥锁
pthread_mutex_destory函数：用于销毁互斥锁
pthread_mutex_lock函数：以原子操作方式给互斥锁加锁
pthread_mutex_unlock函数：以原子操作方式给互斥锁解锁
以上，成功返回0，失败返回errno

# cond类 条件变量
条件变量提供了一种线程间的通知机制,当某个共享数据达到某个值时,唤醒等待这个共享数据的线程.

pthread_cond_init函数：用于初始化条件变量
pthread_cond_destory函数：销毁条件变量
pthread_cond_broadcast函数：以广播的方式唤醒所有等待目标条件变量的线程
pthread_cond_wait函数：用于等待目标条件变量.该函数调用时需要传入 mutex参数(加锁的互斥锁) ,函数执行时,先把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上. 也就是说函数内部会有一次解锁和加锁操作.

# 功能
锁机制的功能
实现多线程同步，通过锁机制，确保任一时刻只能有一个线程能进入关键代码段.

# 封装的功能
类中主要是Linux下三种锁进行封装，将锁的创建于销毁函数封装在类的构造与析构函数中，实现RAII机制
